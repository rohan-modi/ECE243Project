#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
    	
// #include <image_arrays.h>

const int pos1_8_bit_array[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8e, 0xaf, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xce, 0x29, 0x8f, 0x2b, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x4c, 0x61, 0x98, 0x9d, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xbf, 0xff, 0xf9, 0x3a, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0x8f, 0x2b, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x0a, 0xb2, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0xcd, 0x3d, 0x8f, 0x2b, 0xe6, 0x18, 0x0a, 0xb2, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xce, 0x29, 0xf9, 0x3a, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const int pos2_8_bit_array[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8e, 0xaf, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xce, 0x29, 0x8f, 0x2b, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x4c, 0x61, 0x98, 0x9d, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xbf, 0xff, 0xf9, 0x3a, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xf9, 0x3a, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const int pos3_8_bit_array[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8e, 0xaf, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xce, 0x29, 0x8f, 0x2b, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x4c, 0x61, 0x98, 0x9d, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xbf, 0xff, 0xf9, 0x3a, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xf9, 0x3a, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const int pos4_8_bit_array[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8e, 0xaf, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xce, 0x29, 0x8f, 0x2b, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x4c, 0x61, 0x98, 0x9d, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xbf, 0xff, 0xf9, 0x3a, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0xe6, 0x18, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0x8f, 0x2b, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x0a, 0xb2, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xce, 0x29, 0xf9, 0x3a, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const int jump1_8bit_array[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8e, 0xaf, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xcd, 0x3d, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x29, 0xe6, 0x18, 0xe6, 0x18, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x4c, 0x61, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x4c, 0x61, 0x98, 0x9d, 0xce, 0x29, 0x4c, 0x61, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0xeb, 0xf3, 0xbf, 0xff, 0xf9, 0x3a, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0x8f, 0x2b, 0xe6, 0x18, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xeb, 0xf3, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xe6, 0x18, 0x8f, 0x2b, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0x8f, 0x2b, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xf9, 0x3a, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0x8f, 0x2b, 0xcd, 0x3d, 0xe6, 0x18, 0xcd, 0x3d, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xe6, 0x18, 0xe6, 0x18, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x18, 0xce, 0x29, 0xce, 0x29, 0xe6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

	
#define IMAGE_SIZE 256 // 16x16 Image

volatile int pixel_buffer_start; // global variable
short int Buffer1[240][512]; // 240 rows, 512 (320 + padding) columns
short int Buffer2[240][512];
	
unsigned char key1 = 0;
unsigned char key2 = 0;
unsigned char key3 = 0;

bool wPressed = false;
bool aPressed = false;
bool sPressed = false;
bool dPressed = false;
bool upPressed = false;
bool downPressed = false;
bool leftPressed = false;
bool rightPressed = false;

bool gameOver = false;

int xSize = 320-1;
int ySize = 240-1;
int xMin = 0;
int yMin = 0;
int mapEndX = 850;

int gravity = 1;
int playerSize = 16;
int platformSize = 5;

int frames = 5;

const short int WHITE = 0xFFFF;
const short int BLACK = 0x0000;
const short int RED = 0xF800;
const short int BLUE = 0x001F;
const short int GREEN = 0x07E0;

// int pos1_16_bit_array[16][16];


struct platform {
	int startX;
	int startY;
	int width;
	int height;
	short int colour;
	int prevStartX;
	int prevStartY;
	int prevWidth;
	int prevHeight;
};

struct platformTemplate {
	int startX;
	int startY;
	int width;
	int height;
	short int colour;
};

struct Player {
	int x;
	int y;
	int pastX;
	int pastY;
	int speed;
	int jumpSpeed;
	int yVelocity;
    bool* upControl;
    bool* downControl;
    bool* leftControl;
    bool* rightControl;
	short int colour;
	int score;
	int prevScore;
	int currentFrame;
	int frameCount;
	int (*imageData)[16][16];
};

struct PIT_t {
	volatile unsigned int data;
	volatile unsigned int direction;
	volatile unsigned int mask;
	volatile unsigned int edge;
};

struct PIT_t* const buttons = ((struct PIT_t *) 0xFF200050);

// https://dot2pic.com/
const int zero[]={0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x00,0x01,0x01,0x00,0x01,0x01,0x01,0x01};
const int one[]={0x00,0x01,0x00,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x01,0x01,0x01};
const int two[]={0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01};
const int three[]={0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01};
const int four[]={0x01,0x00,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x01};
const int five[]={0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01};
const int six[]={0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01};
const int seven[]={0x01,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01};
const int eight[]={0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01};
const int nine[]={0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01};

const int letterA[]={0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01};
const int letterB[]={0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00};
const int letterC[]={0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01};
const int letterD[]={0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00};
const int letterE[]={0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01};
const int letterF[]={0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};
const int letterG[]={0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01};
const int letterH[]={0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01};
const int letterI[]={0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x01};
const int letterJ[]={0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00};
const int letterK[]={0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x00,0x01,0x01,0x01,0x00,0x00,0x01,0x00,0x01,0x01,0x00,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01};
const int letterL[]={0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01};
const int letterM[]={0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01};
const int letterN[]={0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01};
const int letterO[]={0x00,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x01,0x01,0x00};
const int letterP[]={0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};
const int letterQ[]={0x00,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x00,0x01};
const int letterR[]={0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x01};
const int letterS[]={0x00,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x01,0x01,0x00};
const int letterT[]={0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00};
const int letterU[]={0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x01,0x01,0x00};
const int letterV[]={0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x00};
const int letterW[]={0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01};
const int letterX[]={0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01};
const int letterY[]={0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00};
const int letterZ[]={0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01};

void convert_to_2d(int matrix[][16][16], const int* arr[], int frames, int row, int col);
void plot_pixel(int x, int y, short int line_color);
void wait_for_vsync();
void swap(int* num1, int* num2);
void checkKey(bool* keyBool, unsigned char code, bool extendedChar);
void updateKeys();
void setSolidScreen(short int colour);
void drawRectangle(int xStart, int yStart, int width, int height, short int colour);
void drawPlatforms(struct platform platforms[], int numberOfPlatforms);
void erasePlatforms(struct platform platforms[], int numberOfPlatforms);
void movePlayer(struct Player* player, int gravity, struct platform platforms[], int numberOfPlatforms, struct platform platformLocations[]);
void drawScore(int y, int score, short int colour, int digits[10][15]);
void drawImage(int array[], int startX, int startY, int width, int height);
void drawLetter(int text[], int startX, int startY, short int colour, int size);
void drawString(int startX, int startY, short int colour, int size, char* text, int letters[26][35]);
void drawDigit(const int number[], int startX, int startY, short int colour, int size);
bool buttonPressed();
void drawImage16Bit(int array[][16], int startX, int startY, int width, int height);

int main(void) {
	// Setup
	volatile int* pixel_ctrl_ptr = (int*)0xFF203020;
    *(pixel_ctrl_ptr + 1) = (int) &Buffer1;
    wait_for_vsync();
    pixel_buffer_start = *pixel_ctrl_ptr;
    setSolidScreen(BLACK);
    *(pixel_ctrl_ptr + 1) = (int) &Buffer2;
    pixel_buffer_start = *(pixel_ctrl_ptr + 1);
	
	int borderStartY = ySize/2-5;
	int borderEndY = ySize/2+5;
	int topBottomYDifference = (ySize-platformSize) - (borderStartY);
	bool player1Won = false;

	int digits[10][15];
	for (int i = 0; i < 15; i++) {
		digits[0][i] = zero[i];
		digits[1][i] = one[i];
		digits[2][i] = two[i];
		digits[3][i] = three[i];
		digits[4][i] = four[i];
		digits[5][i] = five[i];
		digits[6][i] = six[i];
		digits[7][i] = seven[i];
		digits[8][i] = eight[i];
		digits[9][i] = nine[i];
	}

    int letters[26][35];
    for (int i = 0; i < 35; i++) {
        letters[0][i] = letterA[i];
        letters[1][i] = letterB[i];
        letters[2][i] = letterC[i];
        letters[3][i] = letterD[i];
        letters[4][i] = letterE[i];
        letters[5][i] = letterF[i];
        letters[6][i] = letterG[i];
        letters[7][i] = letterH[i];
        letters[8][i] = letterI[i];
        letters[9][i] = letterJ[i];
        letters[10][i] = letterK[i];
        letters[11][i] = letterL[i];
        letters[12][i] = letterM[i];
        letters[13][i] = letterN[i];
        letters[14][i] = letterO[i];
        letters[15][i] = letterP[i];
        letters[16][i] = letterQ[i];
        letters[17][i] = letterR[i];
        letters[18][i] = letterS[i];
        letters[19][i] = letterT[i];
        letters[20][i] = letterU[i];
        letters[21][i] = letterV[i];
        letters[22][i] = letterW[i];
        letters[23][i] = letterX[i];
        letters[24][i] = letterY[i];
        letters[25][i] = letterZ[i];
    }
	
	// Player 1 front platforms
	struct platform platformF1_1 = {xMin, borderStartY, xSize, platformSize, BLUE, xMin, yMin, xSize, platformSize};
	struct platform platformF1_2 = {xMin, (ySize/2-platformSize), xSize, platformSize*2, BLUE, xMin, (ySize/2-platformSize), xSize, platformSize*2};
	struct platform platformF1_3 = {xMin, ySize-platformSize, xSize, platformSize, BLUE, xMin, ySize-platformSize, xSize, platformSize};
	struct platform platformF1_4 = {xMin, borderEndY+1, platformSize, ySize/2-platformSize*2, BLUE, xMin, borderEndY+1, platformSize, ySize/2-platformSize*2};
	struct platform platformF1_5 = {mapEndX, borderEndY+1, platformSize, ySize/2-platformSize*2, BLUE, mapEndX, borderEndY+1, platformSize, ySize/2-platformSize*2};
	// Player 1 back platforms
	struct platform platformB1_1 = {xMin, borderStartY, xSize, platformSize, BLUE, xMin, yMin, xSize, platformSize};
	struct platform platformB1_2 = {xMin, (ySize/2-platformSize), xSize, platformSize*2, BLUE, xMin, (ySize/2-platformSize), xSize, platformSize*2};
	struct platform platformB1_3 = {xMin, ySize-platformSize, xSize, platformSize, BLUE, xMin, ySize-platformSize, xSize, platformSize};
	struct platform platformB1_4 = {xMin, borderEndY+1, platformSize, ySize/2-platformSize*2, BLUE, xMin, borderEndY+1, platformSize, ySize/2-platformSize*2};
	struct platform platformB1_5 = {mapEndX, borderEndY+1, platformSize, ySize/2-platformSize*2, BLUE, mapEndX, borderEndY+1, platformSize, ySize/2-platformSize*2};
	// Player 2 front platforms
	struct platform platformF2_1 = {xMin, yMin, xSize, platformSize, BLUE, xMin, yMin, xSize, platformSize};
	struct platform platformF2_2 = {xMin, (ySize/2-platformSize), xSize, platformSize*2, BLUE, xMin, (ySize/2-platformSize), xSize, platformSize*2};
	struct platform platformF2_3 = {xMin, ySize-platformSize, xSize, platformSize, BLUE, xMin, ySize-platformSize, xSize, platformSize};
	struct platform platformF2_4 = {xMin, yMin+platformSize, platformSize, ySize/2-platformSize*2, BLUE, xMin, yMin+platformSize, platformSize, ySize/2-platformSize*2};
	struct platform platformF2_5 = {mapEndX, yMin+platformSize, platformSize, ySize/2-platformSize*2, BLUE, mapEndX, yMin+platformSize, platformSize, ySize/2-platformSize*2};
	// Player 2 back platforms
	struct platform platformB2_1 = {xMin, yMin, xSize, platformSize, BLUE, xMin, yMin, xSize, platformSize};
	struct platform platformB2_2 = {xMin, (ySize/2-platformSize), xSize, platformSize*2, BLUE, xMin, (ySize/2-platformSize), xSize, platformSize*2};
	struct platform platformB2_3 = {xMin, ySize-platformSize, xSize, platformSize, BLUE, xMin, ySize-platformSize, xSize, platformSize};
	struct platform platformB2_4 = {xMin, yMin+platformSize, platformSize, ySize/2-platformSize*2, BLUE, xMin, yMin+platformSize, platformSize, ySize/2-platformSize*2};
	struct platform platformB2_5 = {mapEndX, yMin+platformSize, platformSize, ySize/2-platformSize*2, BLUE, mapEndX, yMin+platformSize, platformSize, ySize/2-platformSize*2};
		
	// Jumpers
	struct platform platformF1_6;
	struct platform platformF1_7;
	struct platform platformF1_8;
	struct platform platformF1_9;
	struct platform platformF1_10;
	struct platform platformF1_11;
	struct platform platformF1_12;
	struct platform platformF1_13;
	struct platform platformF1_14;
	// Jumpers
	struct platform platformB1_6;
	struct platform platformB1_7;
	struct platform platformB1_8;
	struct platform platformB1_9;
	struct platform platformB1_10;
	struct platform platformB1_11;
	struct platform platformB1_12;
	struct platform platformB1_13;
	struct platform platformB1_14;
	// Jumpers
	struct platform platformF2_6;
	struct platform platformF2_7;
	struct platform platformF2_8;
	struct platform platformF2_9;
	struct platform platformF2_10;
	struct platform platformF2_11;
	struct platform platformF2_12;
	struct platform platformF2_13;
	struct platform platformF2_14;
	// Jumpers
	struct platform platformB2_6;
	struct platform platformB2_7;
	struct platform platformB2_8;
	struct platform platformB2_9;
	struct platform platformB2_10;
	struct platform platformB2_11;
	struct platform platformB2_12;
	struct platform platformB2_13;
	struct platform platformB2_14;
		
	struct platformTemplate borderPlatform1 = {xMin, borderEndY+1, platformSize, ySize/2-platformSize*2, BLUE};
	struct platformTemplate borderPlatform2 = {mapEndX, borderEndY+1, platformSize, ySize/2-platformSize*2, BLUE};
	struct platformTemplate borderPlatform3 = {xMin, yMin+platformSize, platformSize, ySize/2-platformSize*2, BLUE};
	struct platformTemplate borderPlatform4 = {mapEndX, yMin+platformSize, platformSize, ySize/2-platformSize*2, BLUE};
	struct platformTemplate borderPlatformSetup[] = {borderPlatform1, borderPlatform2, borderPlatform3, borderPlatform4};

	struct platformTemplate platform1 = {100, borderEndY+75, 50, platformSize, GREEN};
	struct platformTemplate platform2 = {175, borderEndY+50, 50, platformSize, GREEN};
	struct platformTemplate platform3 = {300, borderEndY+75, 50, platformSize, GREEN};
	struct platformTemplate platform4 = {385, ySize-50-platformSize, platformSize, 50, GREEN};
	struct platformTemplate platform5 = {425, borderEndY+75, 75, platformSize, GREEN};
	struct platformTemplate platform6 = {525, borderEndY+50, 75, platformSize, GREEN};
	struct platformTemplate platform7 = {625, borderEndY+25, 75, platformSize, GREEN};
	struct platformTemplate platform8 = {725, borderEndY+50, 75, platformSize, GREEN};
	struct platformTemplate platform9 = {800, borderEndY+50, platformSize, ySize-borderEndY-platformSize-50, GREEN};
	struct platformTemplate platformSetup[] = {platform1, platform2, platform3, platform4, platform5, platform6, platform7, platform8, platform9};
	
	struct platform platforms1[] = {platformF1_1, platformF1_2, platformF1_3, platformF1_4, platformF1_5, platformF1_6, platformF1_7, platformF1_8, platformF1_9, platformF1_10, platformF1_11, platformF1_12, platformF1_13, platformF1_14};
	struct platform platformLocations1[] = {platformB1_1, platformB1_2, platformB1_3, platformB1_4, platformB1_5, platformB1_6, platformB1_7, platformB1_8, platformB1_9, platformB1_10, platformB1_11, platformB1_12, platformB1_13, platformB1_14};
	
	struct platform platforms2[] = {platformF2_1, platformF2_2, platformF2_3, platformF2_4, platformF2_5, platformF2_6, platformF2_7, platformF2_8, platformF2_9, platformF2_10, platformF2_11, platformF2_12, platformF2_13, platformF2_14};
	struct platform platformLocations2[] = {platformB2_1, platformB2_2, platformB2_3, platformB2_4, platformB2_5, platformB2_6, platformB2_7, platformB2_8, platformB2_9, platformB2_10, platformB2_11, platformB2_12, platformB2_13, platformB2_14};
		
	
	int numberOfPlatforms = sizeof(platforms1)/sizeof(platforms1[0]);
	
	int player1StartX = xSize/2;
	int player1StartY = borderEndY + 1;
	int player2StartX = xSize/2;
	int player2StartY = platformSize + 1;
	
	int playerSpeed = 3;
	int playerJumpSpeed = -10;
	
	// Player setup
	const int* animation_player1_8_bit[] = {pos1_8_bit_array, pos2_8_bit_array, pos3_8_bit_array, pos4_8_bit_array, jump1_8bit_array};
	int animation_player1_16_bit [frames][16][16];
	convert_to_2d(animation_player1_16_bit, animation_player1_8_bit, frames, 16, 16);

    struct Player player1 = {xSize/2, ySize/2+15, xSize/2, ySize/2+15, 3, -10, 0, &wPressed, &sPressed, &aPressed, &dPressed, RED, 0, 0, 0, frames, animation_player1_16_bit};
    struct Player player2 = {xSize/2, 6, xSize/2, 6, 3, -10, 0, &upPressed, &downPressed, &leftPressed, &rightPressed, WHITE, 0, 0, 0, frames, animation_player1_16_bit};


	
	while (1) {
		gameOver = false;
		player1Won = false;
		
		setSolidScreen(BLACK);
		wait_for_vsync();
		pixel_buffer_start = *(pixel_ctrl_ptr + 1);
		setSolidScreen(BLACK);
		wait_for_vsync();
		pixel_buffer_start = *(pixel_ctrl_ptr + 1);
		setSolidScreen(BLACK);
		wait_for_vsync();
		pixel_buffer_start = *(pixel_ctrl_ptr + 1);
		
		player1.x = player1StartX;
		player1.y = player1StartY;
		player2.x = player2StartX;
		player2.y = player2StartY;
		player1.pastX = player1.x;
		player1.pastY = player1.y;
		player2.pastX = player2.x;
		player2.pastY = player2.y;
		
		player1.speed = playerSpeed;
		player1.jumpSpeed = playerJumpSpeed;
		player1.yVelocity = 0;
		
		player2.speed = playerSpeed;
		player2.jumpSpeed = playerJumpSpeed;
		player2.yVelocity = 0;
		
		bool wPressed = false;
		aPressed = false;
		sPressed = false;
		dPressed = false;
		upPressed = false;
		downPressed = false;
		leftPressed = false;
		rightPressed = false;
		
		for (int i = 3; i < 5; i++) {
			platforms1[i].startX = borderPlatformSetup[i-3].startX;
			platforms1[i].prevStartX = borderPlatformSetup[i-3].startX;
			platforms1[i].startY = borderPlatformSetup[i-3].startY;
			platforms1[i].prevStartY = borderPlatformSetup[i-3].startY;
			platforms1[i].colour = borderPlatformSetup[i-3].colour;
			platforms1[i].height = borderPlatformSetup[i-3].height;
			platforms1[i].prevHeight = borderPlatformSetup[i-3].height;
			platforms1[i].width = borderPlatformSetup[i-3].width;
			platforms1[i].prevWidth = borderPlatformSetup[i-3].width;
			platformLocations1[i].startX = borderPlatformSetup[i-3].startX;
			platformLocations1[i].prevStartX = borderPlatformSetup[i-3].startX;
			platformLocations1[i].startY = borderPlatformSetup[i-3].startY;
			platformLocations1[i].prevStartY = borderPlatformSetup[i-3].startY;
			platformLocations1[i].colour = borderPlatformSetup[i-3].colour;
			platformLocations1[i].height = borderPlatformSetup[i-3].height;
			platformLocations1[i].prevHeight = borderPlatformSetup[i-3].height;
			platformLocations1[i].width = borderPlatformSetup[i-3].width;
			platformLocations1[i].prevWidth = borderPlatformSetup[i-3].width;
			platforms2[i].startX = borderPlatformSetup[i-3].startX;
			platforms2[i].prevStartX = borderPlatformSetup[i-3].startX;
			platforms2[i].startY = borderPlatformSetup[i-3].startY-topBottomYDifference;
			platforms2[i].prevStartY = borderPlatformSetup[i-3].startY-topBottomYDifference;
			platforms2[i].colour = borderPlatformSetup[i-3].colour;
			platforms2[i].height = borderPlatformSetup[i-3].height;
			platforms2[i].prevHeight = borderPlatformSetup[i-3].height;
			platforms2[i].width = borderPlatformSetup[i-3].width;
			platforms2[i].prevWidth = borderPlatformSetup[i-3].width;
			platformLocations2[i].startX = borderPlatformSetup[i-3].startX;
			platformLocations2[i].prevStartX = borderPlatformSetup[i-3].startX;
			platformLocations2[i].startY = borderPlatformSetup[i-3].startY-topBottomYDifference;
			platformLocations2[i].prevStartY = borderPlatformSetup[i-3].startY-topBottomYDifference;
			platformLocations2[i].colour = borderPlatformSetup[i-3].colour;
			platformLocations2[i].height = borderPlatformSetup[i-3].height;
			platformLocations2[i].prevHeight = borderPlatformSetup[i-3].height;
			platformLocations2[i].width = borderPlatformSetup[i-3].width;
			platformLocations2[i].prevWidth = borderPlatformSetup[i-3].width;
		}
		
		for (int i = 5; i < numberOfPlatforms; i++) {
			platforms1[i].startX = platformSetup[i-5].startX;
			platforms1[i].prevStartX = platformSetup[i-5].startX;
			platforms1[i].startY = platformSetup[i-5].startY;
			platforms1[i].prevStartY = platformSetup[i-5].startY;
			platforms1[i].colour = platformSetup[i-5].colour;
			platforms1[i].height = platformSetup[i-5].height;
			platforms1[i].prevHeight = platformSetup[i-5].height;
			platforms1[i].width = platformSetup[i-5].width;
			platforms1[i].prevWidth = platformSetup[i-5].width;
			platformLocations1[i].startX = platformSetup[i-5].startX;
			platformLocations1[i].prevStartX = platformSetup[i-5].startX;
			platformLocations1[i].startY = platformSetup[i-5].startY;
			platformLocations1[i].prevStartY = platformSetup[i-5].startY;
			platformLocations1[i].colour = platformSetup[i-5].colour;
			platformLocations1[i].height = platformSetup[i-5].height;
			platformLocations1[i].prevHeight = platformSetup[i-5].height;
			platformLocations1[i].width = platformSetup[i-5].width;
			platformLocations1[i].prevWidth = platformSetup[i-5].width;
			platforms2[i].startX = platformSetup[i-5].startX;
			platforms2[i].prevStartX = platformSetup[i-5].startX;
			platforms2[i].startY = platformSetup[i-5].startY-topBottomYDifference;
			platforms2[i].prevStartY = platformSetup[i-5].startY-topBottomYDifference;
			platforms2[i].colour = platformSetup[i-5].colour;
			platforms2[i].height = platformSetup[i-5].height;
			platforms2[i].prevHeight = platformSetup[i-5].height;
			platforms2[i].width = platformSetup[i-5].width;
			platforms2[i].prevWidth = platformSetup[i-5].width;
			platformLocations2[i].startX = platformSetup[i-5].startX;
			platformLocations2[i].prevStartX = platformSetup[i-5].startX;
			platformLocations2[i].startY = platformSetup[i-5].startY-topBottomYDifference;
			platformLocations2[i].prevStartY = platformSetup[i-5].startY-topBottomYDifference;
			platformLocations2[i].colour = platformSetup[i-5].colour;
			platformLocations2[i].height = platformSetup[i-5].height;
			platformLocations2[i].prevHeight = platformSetup[i-5].height;
			platformLocations2[i].width = platformSetup[i-5].width;
			platformLocations2[i].prevWidth = platformSetup[i-5].width;
		}
		// Main loop
		while (1) {
			// Get key presses
			updateKeys();

			// Erase previous players		
			drawRectangle(player1.pastX, player1.pastY, playerSize, playerSize, BLACK);
			drawRectangle(player2.pastX, player2.pastY, playerSize, playerSize, BLACK);
			erasePlatforms(platforms1, numberOfPlatforms);
			erasePlatforms(platforms2, numberOfPlatforms);

			drawScore(borderEndY + 5, player1.prevScore, BLACK, digits);
			drawScore(yMin + 5 + platformSize, player2.prevScore, BLACK, digits);

			// Update past variables
			player1.pastX = player1.x;
			player1.pastY = player1.y;

			player2.pastX = player2.x;
			player2.pastY = player2.y;

			player1.prevScore = player1.score;
			player2.prevScore = player2.score;

			for (int i = 3; i < numberOfPlatforms; i++) {
				platforms1[i].prevStartX = platforms1[i].startX;
				platforms1[i].prevStartY = platforms1[i].startY;
				platforms1[i].prevWidth = platforms1[i].width;
				platforms1[i].prevHeight = platforms1[i].height;
				platforms2[i].prevStartX = platforms2[i].startX;
				platforms2[i].prevStartY = platforms2[i].startY;
				platforms2[i].prevWidth = platforms2[i].width;
				platforms2[i].prevHeight = platforms2[i].height;
			}

			// Move players
			movePlayer(&player1, gravity, platforms1, numberOfPlatforms, platformLocations1);
			movePlayer(&player2, gravity, platforms2, numberOfPlatforms, platformLocations2);

			if (player1.score != player1.prevScore) {
				player1Won = true;
			}

			drawScore(borderEndY + 5, player1.prevScore, BLACK, digits);
			drawScore(yMin + 5 + platformSize, player2.prevScore, BLACK, digits);

			player1.prevScore = player1.score;
			player2.prevScore = player2.score;

			// Draw stuff
			drawPlatforms(platforms1, numberOfPlatforms);
			drawPlatforms(platforms2, numberOfPlatforms);

			// Players
			// Update current frame if player is jumping
			if(player1.yVelocity != 0){
				player1.currentFrame = frames - 1;
			}
			else{
				player1.currentFrame = (player1.currentFrame + 1) % (player1.frameCount - 1);
			}
			drawImage16Bit(player1.imageData[player1.currentFrame], player1.x, player1.y, playerSize, playerSize);
			drawRectangle(player2.x, player2.y, playerSize, playerSize, player2.colour);

			drawScore(borderEndY + 5, player1.score, WHITE, digits);
			drawScore(yMin + 5 + platformSize, player2.score, WHITE, digits);


			if (gameOver) {
				break;	
			}

			// Switch buffers
			wait_for_vsync();
			pixel_buffer_start = *(pixel_ctrl_ptr + 1);
		}
		drawString(xSize/2-90, ySize/2-14, WHITE, 4, "GAME OVER", letters);
		int yTop = ySize/4 - 7;
		int yBottom = ySize*3/4 - 7;
		if (player1Won) {
			drawString(xSize/2-30, yBottom, WHITE, 2, "WINNER", letters);
			drawString(xSize/2-25, yTop, WHITE, 2, "LOSER", letters);
		} else {
			drawString(xSize/2-30, yTop, WHITE, 2, "WINNER", letters);
			drawString(xSize/2-25, yBottom, WHITE, 2, "LOSER", letters);	
		}
		wait_for_vsync();
		int data;
		while (1) {
			updateKeys();
			if (buttonPressed()) {
				gameOver = false;
				break;
			}
		}
	}
	return 0;
}

// Function to convert 1D array to 2D array and merge two adjacent 8-bit values into one 16-bit value
// void convert_to_2d(int matrix[16][16], const int *arr, int row, int col) {
//     int i, j, k = 0;
//     for (i = 0; i < row; i++) {
//         for (j = 0; j < col; j++) {
//             // Merge two 8-bit values into one 16-bit value with adjusted byte order
//             int merged_value = (int)arr[k + 1] << 8 | arr[k];
//             matrix[i][j] = merged_value; // Store merged value in the 2D array
//             k += 2; // Move to the next pair of values in the 1D array
//         }
//     }
// }
void convert_to_2d(int matrix[][16][16], const int* arr[], int frames, int row, int col) {
    for (int f = 0; f < frames; f++) {
        int k = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                // Merge two 8-bit values into one 16-bit value with adjusted byte order
                int merged_value = (int)arr[f][k + 1] << 8 | arr[f][k];
                matrix[f][i][j] = merged_value; // Store merged value in the 2D array
                k += 2; // Move to the next pair of values in the 1D array
            }
        }
    }
}


void plot_pixel(int x, int y, short int line_color) {
	volatile short int *one_pixel_address;
	one_pixel_address = (short int*) (pixel_buffer_start + (y << 10) + (x << 1));
	*one_pixel_address = line_color;
}

void wait_for_vsync() {
	volatile int* pixel_ctrl_ptr = (int*) 0xFF203020;
	(*pixel_ctrl_ptr) = 1;
	int statusRegister;
	int statusBit;
	while (1) {
		statusRegister = *(pixel_ctrl_ptr + 3);
		statusBit = (statusRegister & 1);	
		if (statusBit == 0) {
			return;	
		}
	}
}

void swap(int* num1, int* num2) {
	int temp = (*num1);
	(*num1) = (*num2);
	(*num2) = temp;
}

void checkKey(bool* keyBool, unsigned char code, bool extendedChar) {
	if (key1 == code && key2 != 0xF0) {
		(*keyBool) = true;	
	}
	if (key1 == code && key2 == 0xF0) {
		(*keyBool) = false;	
	}
	if (extendedChar) {
		if (key1 == 0x72 && key2 == 0xE0 && key3 != 0xF0) {
			(*keyBool) = true;	
		}
		if (key1 == 0x72 && key2 == 0xE0 && key3 != 0xF0) {
			(*keyBool) = true;	
		}
	}
}

void updateKeys() {
	volatile int* PS2_ptr = (int *) 0xFF200100;
	int data;
	data = *PS2_ptr;
	if (data & 0x8000) {
		key3 = key2;
		key2 = key1;
		key1 = data & 0xFF;	
	}
	checkKey(&wPressed, 0x1D, false);
	checkKey(&aPressed, 0x1C, false);
	checkKey(&sPressed, 0x1B, false);
	checkKey(&dPressed, 0x23, false);
	checkKey(&upPressed, 0x75, true);
	checkKey(&downPressed, 0x72, true);
	checkKey(&leftPressed, 0x6B, true);
	checkKey(&rightPressed, 0x74, true);
}

void setSolidScreen(short int colour) {
	for (int x = xMin; x < xSize; x++) {
		for (int y = 0; y < ySize; y++) {
			plot_pixel(x, y, colour);	
		}
	}
}

void drawRectangle(int xStart, int yStart, int width, int height, short int colour) {
	for (int x = xStart; x < width+xStart; x++) {
		for (int y = yStart; y < height+yStart; y++) {
			plot_pixel(x, y, colour);	
		}
	}
}

void drawPlatforms(struct platform platforms[], int numberOfPlatforms) {
	for (int i = 0; i < numberOfPlatforms; i++) {
		if (platforms[i].startX >= xMin && platforms[i].startX + platforms[i].width <= xSize) {
			drawRectangle(platforms[i].startX, platforms[i].startY, platforms[i].width, platforms[i].height, platforms[i].colour);	
		} else if (platforms[i].startX >= xMin) {
			int newWidth = xSize - platforms[i].startX;
			drawRectangle(platforms[i].startX, platforms[i].startY, newWidth, platforms[i].height, platforms[i].colour);
		}
	}			
}

void erasePlatforms(struct platform platforms[], int numberOfPlatforms) {
	for (int i = 3; i < numberOfPlatforms; i++) {
		drawRectangle(platforms[i].prevStartX, platforms[i].prevStartY, platforms[i].prevWidth, platforms[i].prevHeight, BLACK);	
	}
}

void movePlayer(struct Player* player, int gravity, struct platform platforms[], int numberOfPlatforms, struct platform platformLocations[]) {
	int topBoundAbove, bottomBoundAbove, topBoundBelow, bottomBoundBelow;
	int xBoundLeft, xBoundRight;
	if (*(player->upControl)) {
        for (int i = 0; i < numberOfPlatforms; i++) {
            if (player->y == (platforms[i].startY-playerSize)) {
                if (player->x+playerSize > platforms[i].startX && player->x < (platforms[i].startX + platforms[i].width)) {
                    player->yVelocity = player->jumpSpeed;
                }
            }
        }
	}

	player->yVelocity += gravity;
	
    for (int i = 0; i < numberOfPlatforms; i++) {
		topBoundAbove = platforms[i].startY-playerSize-abs(player->yVelocity);
		bottomBoundAbove = platforms[i].startY+platforms[i].height;
		topBoundBelow = platforms[i].startY+platforms[i].height;
		bottomBoundBelow = platforms[i].startY+platforms[i].height+abs(player->yVelocity);
		xBoundLeft = platforms[i].startX;
		xBoundRight = platforms[i].startX + platforms[i].width;
		
		if (player->x+playerSize > xBoundLeft && player->x < xBoundRight) {
			if (player->y >= topBoundAbove && player->y <= bottomBoundAbove && player->yVelocity > 0) {
				player->y = platforms[i].startY-playerSize;
				player->yVelocity = 0;
			} else if (player->y >= topBoundBelow && player->y <= bottomBoundBelow && player->yVelocity < 0) {
				player->y = platforms[i].startY+platforms[i].height+1;
				player->yVelocity = 0;
			}
		}
    }
	player->y += player->yVelocity;
	int difference;
	bool adjustment = false;
	int extraDistance;
	if ((*(player->leftControl))) {
		bool hitLeftWall = false;
		for (int i = 3; i < numberOfPlatforms; i++) {
			if (player->x >= platforms[i].startX+platforms[i].width && player->x - player->speed <= platforms[i].startX+platforms[i].width) {
				if (player->y+playerSize > platforms[i].startY && player->y < platforms[i].startY + platforms[i].height) {
					hitLeftWall = true;
					extraDistance = player->x - (platforms[i].startX + platforms[i].width);
					if (extraDistance > 0) {
						hitLeftWall = false;
						adjustment = true;
					}
					break;
				}
			}
		}
		if (hitLeftWall == false) {
			for (int i = 3; i < numberOfPlatforms; i++) {
				if (adjustment) {
					platformLocations[i].startX += extraDistance;	
				} else {
					platformLocations[i].startX += player->speed;
				}
				if (platformLocations[i].startX > xSize) {
					platforms[i].width = 0;
					platforms[i].startX = xSize;
				} else if (platformLocations[i].startX + platformLocations[i].width > xSize) {
					difference = (platformLocations[i].startX + platformLocations[i].width) - xSize;
					platforms[i].width = platformLocations[i].width - difference;
					platforms[i].startX = platformLocations[i].startX;
				} else if (platformLocations[i].startX <= xMin && platformLocations[i].startX + platformLocations[i].width >= xMin) {
					platforms[i].startX = xMin;
					platforms[i].width = platformLocations[i].startX + platformLocations[i].width;
				} else {
					platforms[i].width = platformLocations[i].width;
					platforms[i].startX = platformLocations[i].startX;
				}
			}
		}
	}
	if ((*(player->rightControl))) {
		bool hitRightWall = false;
		bool adjustment = false;
		int playerRight = player->x + playerSize;
		int platformLeft;
		int extraDistance;
		int difference;
		for (int i = 3; i < numberOfPlatforms; i++) {
			platformLeft = platforms[i].startX;
			if (playerRight <= platformLeft && playerRight + player->speed >= platformLeft) {
				if (player->y+playerSize > platforms[i].startY && player->y < platforms[i].startY + platforms[i].height) {
					extraDistance = platforms[i].startX - (player->x+playerSize);
					hitRightWall = true;
					if (i == 4) {
						player->score++;
						gameOver = true;
					}
					if (extraDistance > 0) {
						hitRightWall = false;
						adjustment = true;
					}
					break;
				}
			}
		}
		if (hitRightWall == false) {
			for (int i = 3; i < numberOfPlatforms; i++) {
				if (adjustment) {
					platformLocations[i].startX -= extraDistance;
				} else {
					platformLocations[i].startX -= player->speed;
				}
				if (platformLocations[i].startX < xMin) {
					if (platformLocations[i].startX + platformLocations[i].width < xMin) {
						platforms[i].width = 0;
					} else {
						platforms[i].width = platformLocations[i].startX + platformLocations[i].width;
					}
					platforms[i].startX = xMin;
				} else if (platformLocations[i].startX >= xMin && platformLocations[i].startX + platformLocations[i].width <= xSize) {
					platforms[i].width = platformLocations[i].width;
					platforms[i].startX = platformLocations[i].startX;
				} else {
					difference = xSize - platformLocations[i].startX;
					platforms[i].width = difference;
					platforms[i].startX = platformLocations[i].startX;
				}
			}
		}
	}
}

void drawDigit(const int number[], int startX, int startY, short int colour, int size) {
	int index = 0;
	for (int y = startY; y < startY+5*size; y += size) {
		for (int x = startX; x < startX+3*size; x += size) {
			if (number[index]) {
				drawRectangle(x, y, size, size, colour);
			}
			index ++;
		}
	}
}

void drawLetter(int text[], int startX, int startY, short int colour, int size) {
	int index = 0;
	for (int y = startY; y < startY+7*size; y += size) {
		for (int x = startX; x < startX+5*size; x += size) {
			if (text[index]) {
				drawRectangle(x, y, size, size, colour);
			}
			index++;
		}
	}
}

void drawImage(int array[], int startX, int startY, int width, int height) {
	int index = 0;
	int colour;
	for (int y = startY; y < startY+height; y++) {
		for (int x = startX; x < startX+width; x++) {

			colour = array[index++];
			if (colour != 0) {
				plot_pixel(x, y, colour);
			}
		}
	}	
}

void drawScore(int y, int score, short int colour, int digits[10][15]) {
	int x = xSize - 4;
	int digit;
	if (score == 0) {
		drawDigit(zero, x, y, colour, 1);
		return;
	}
	while (score) {
		digit = score % 10;
		drawDigit(digits[digit], x, y, colour, 1);
		score /= 10;
		x -= 4;
	}
}

void drawString(int startX, int startY, short int colour, int size, char* text, int letters[26][35]) {
	char letter;
    int charIndex;
    int x = startX;
	for (int i = 0; i < strlen(text); i++) {
		if (text[i] == ' ') {
			x += (6*size);
			continue;
		}
        letter = toupper(text[i]);
        charIndex = ((int) letter) - 65;
        drawLetter(letters[charIndex], x, startY, colour, size);
        x += (6*size);
    }
}

bool buttonPressed() {
	if (buttons->edge & 0x1) {
		buttons->edge = 0xf;
		return true;
	}
}

void drawImage16Bit(int array[][16], int startX, int startY, int width, int height) {
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            int colour = array[y][x];
			if(colour != BLACK){
            	plot_pixel(startX + x, startY + y, colour);
			}
        }
    }
}



/*
	// WALL
	struct platform wall1 = {255, 65, platformSize, 50, WHITE};

	struct platform wall2 = {255, 65 + ySize/2, platformSize, 50, WHITE};

	struct platform walls[] = {wall1, wall2};

    int numberOfWalls = sizeof(walls)/sizeof(walls[0]);

    // DRAW STUFF
    drawWalls(walls, numberOfWalls);


    void drawWalls(struct platform walls[], int numberOfWalls){
	for(int i = 0; i < numberOfWalls; i++){
		drawRectangle(walls[i].startX, walls[i].startY, walls[i].width, walls[i].height, walls[i].colour);
	}
}

void movePlayer(struct Player* player, int gravity, struct platform platforms[], int numberOfPlatforms, struct platform walls[], int numberOfWalls) {
    int topBoundAbove, bottomBoundAbove, topBoundBelow, bottomBoundBelow;
    int xBoundLeft, xBoundRight;
    int yBoundTop, yBoundBottom; // Bounds for vertical collision detection
    bool collisionDetected = false;

    // Jump detection
    if (*(player->upControl)) {
        for (int i = 0; i < numberOfPlatforms; i++) {
            if (player->y == (platforms[i].startY - playerSize)) {
                if (player->x + playerSize > platforms[i].startX && player->x < (platforms[i].startX + platforms[i].width)) {
                    player->yVelocity = player->jumpSpeed;
                    // play_jump_sound((volatile int*)AUDIO_BASE); Optional sound effect
                }
            }
        }           
    }

    // Apply gravity
    if (player->y < ySize - playerSize - platformSize) {
        player->yVelocity += gravity;
    }

    // Platform collision detection
    for (int i = 0; i < numberOfPlatforms; i++) {
        topBoundAbove = platforms[i].startY - playerSize - abs(player->yVelocity);
        bottomBoundAbove = platforms[i].startY + platforms[i].height;
        topBoundBelow = platforms[i].startY + platforms[i].height;
        bottomBoundBelow = platforms[i].startY + platforms[i].height + abs(player->yVelocity);
        xBoundLeft = platforms[i].startX;
        xBoundRight = platforms[i].startX + platforms[i].width;

        if (player->x + playerSize > xBoundLeft && player->x < xBoundRight) {
            if (player->y >= topBoundAbove && player->y <= bottomBoundAbove && player->yVelocity > 0) {
                player->y = platforms[i].startY - playerSize;
                player->yVelocity = 0;
            } else if (player->y >= topBoundBelow && player->y <= bottomBoundBelow && player->yVelocity < 0) {
                player->y = platforms[i].startY + platforms[i].height + 1;
                player->yVelocity = 0;
            }
        }
    }

    // Wall collision detection and resolution
    for (int i = 0; i < numberOfWalls; i++) {
        xBoundLeft = walls[i].startX;
        xBoundRight = walls[i].startX + walls[i].width;
        yBoundTop = walls[i].startY;
        yBoundBottom = walls[i].startY + walls[i].height;

        // Predictive collision detection based on player's next position
        int playerNextX = player->x + ((*(player->rightControl)) - (*(player->leftControl))) * player->speed;

        if (player->y + playerSize > yBoundTop && player->y < yBoundBottom) {
            if ((*(player->rightControl)) && playerNextX + playerSize > xBoundLeft && player->x < xBoundRight) {
                player->x = xBoundLeft - playerSize; // Prevent entering the wall
                collisionDetected = true;
            }
            else if ((*(player->leftControl)) && playerNextX < xBoundRight && playerNextX + playerSize > xBoundLeft) {
                player->x = xBoundRight; // Prevent entering the wall
                collisionDetected = true;
            }
        }
    }

    // Apply horizontal movement if no collision detected
    if (!collisionDetected) {
        if ((*(player->leftControl)) && player->x > 0) {
            player->x -= player->speed;
        }
        if ((*(player->rightControl)) && player->x < xSize - playerSize) {
            player->x += player->speed;
        }
    }

    // Apply vertical movement and prevent the player from moving out of bounds
    player->y += player->yVelocity;
    if (player->y < 0) {
        player->y = 0;
        player->yVelocity = 0;
    } else if (player->y > ySize - playerSize) {
        player->y = ySize - playerSize;
        player->yVelocity = 0;
    }
}


*/



/*

#define AUDIO_BASE 0xFF203040

extern const unsigned int mario_sound_data[];
extern const unsigned int mario_sound_data_length;


void play_jump_sound(volatile int* audio_ptr) {
    for (unsigned int i = 0; i < mario_sound_data_length; i++) {
        // Use the write_audio_sample function to handle the waiting and writing
        write_audio_sample(audio_ptr, mario_sound_data[i]);
    }
}

void write_audio_sample(volatile int* audio_ptr, int sample) {
    int fifo_space;
    // Loop until there is enough space in the FIFO for a new sample
    do {
        fifo_space = read_fifo_space(audio_ptr);
        // Extract available write space for left/right channels and check if at least one slot is open
    } while (((fifo_space & 0x00FF0000) >> 16) == 0);

    // If we exit the loop, we have space to write
    *(audio_ptr + 2) = sample; // Write to left channel
    *(audio_ptr + 3) = sample; // Write to right channel (duplicate for mono sound)
}

int read_fifo_space(volatile int* audio_ptr) {
    return *(audio_ptr + 1); // Read the fifospace register
}
*/